-- Quiz System Schema + Seed
-- Run this in Supabase SQL editor.

-- Required for gen_random_uuid()
create extension if not exists pgcrypto;

-- =========================
-- TABLES
-- =========================

create table if not exists public.teams (
  id int primary key,
  name text not null
);

create table if not exists public.categories (
  id int generated by default as identity primary key,
  name text not null,
  icon text
);

create table if not exists public.questions (
  id uuid primary key default gen_random_uuid(),
  category_id int not null references public.categories(id) on delete restrict,
  question_text text not null,
  media_url text,
  answer text,
  duration_sec int not null default 20,
  created_at timestamp with time zone not null default now()
);

create table if not exists public.games (
  id uuid primary key default gen_random_uuid(),
  status text not null default 'active' check (status in ('active','paused','finished')),
  current_question_id uuid references public.questions(id) on delete set null,
  created_at timestamp with time zone not null default now()
);

-- scores are per game (so each quiz-avond is apart)
create table if not exists public.game_scores (
  game_id uuid not null references public.games(id) on delete cascade,
  team_id int not null references public.teams(id) on delete restrict,
  score int not null default 0,
  primary key (game_id, team_id)
);

create table if not exists public.qr_tokens (
  token text primary key,
  question_id uuid not null references public.questions(id) on delete cascade,
  category_id int not null references public.categories(id) on delete restrict,
  created_at timestamp with time zone not null default now()
);

create table if not exists public.answers (
  id uuid primary key default gen_random_uuid(),
  game_id uuid not null references public.games(id) on delete cascade,
  question_id uuid not null references public.questions(id) on delete cascade,
  team_id int not null references public.teams(id) on delete restrict,
  answer_text text,
  is_correct boolean,
  points_awarded int not null default 0,
  created_at timestamp with time zone not null default now()
);

-- token usage is per game (so tokens can be reused each new game)
create table if not exists public.game_token_uses (
  game_id uuid not null references public.games(id) on delete cascade,
  token text not null references public.qr_tokens(token) on delete cascade,
  used_by_team_id int references public.teams(id) on delete set null,
  used_at timestamp with time zone not null default now(),
  primary key (game_id, token)
);

-- who is admin (Supabase auth users)
create table if not exists public.admins (
  user_id uuid primary key
);

-- simple pointer to an "active" game (1 row)
create table if not exists public.app_state (
  id int primary key default 1,
  active_game_id uuid references public.games(id) on delete set null,
  updated_at timestamp with time zone not null default now(),
  constraint app_state_singleton check (id = 1)
);

insert into public.app_state (id) values (1)
on conflict (id) do nothing;

-- =========================
-- HELPERS / SECURITY
-- =========================

create or replace function public.is_admin()
returns boolean
language sql
stable
as $$
  select exists(select 1 from public.admins a where a.user_id = auth.uid());
$$;

-- =========================
-- RLS
-- =========================

alter table public.teams enable row level security;
alter table public.categories enable row level security;
alter table public.questions enable row level security;
alter table public.games enable row level security;
alter table public.game_scores enable row level security;
alter table public.qr_tokens enable row level security;
alter table public.answers enable row level security;
alter table public.game_token_uses enable row level security;
alter table public.admins enable row level security;
alter table public.app_state enable row level security;

-- Public read for quiz data
drop policy if exists "read teams" on public.teams;
create policy "read teams" on public.teams for select using (true);

drop policy if exists "read categories" on public.categories;
create policy "read categories" on public.categories for select using (true);

drop policy if exists "read questions" on public.questions;
create policy "read questions" on public.questions for select using (true);

drop policy if exists "read games" on public.games;
create policy "read games" on public.games for select using (true);

drop policy if exists "read scores" on public.game_scores;
create policy "read scores" on public.game_scores for select using (true);

drop policy if exists "read qr_tokens" on public.qr_tokens;
create policy "read qr_tokens" on public.qr_tokens for select using (true);

drop policy if exists "read answers" on public.answers;
create policy "read answers" on public.answers for select using (true);

drop policy if exists "read game_token_uses" on public.game_token_uses;
create policy "read game_token_uses" on public.game_token_uses for select using (true);

drop policy if exists "read app_state" on public.app_state;
create policy "read app_state" on public.app_state for select using (true);

-- admin table: only admins can see it (optional)
drop policy if exists "admins read self" on public.admins;
create policy "admins read self" on public.admins
for select using (public.is_admin());

-- Admin write policies (tables mutated via RPC, but allow admins direct edit too)
drop policy if exists "admin write games" on public.games;
create policy "admin write games" on public.games
for all using (public.is_admin()) with check (public.is_admin());

drop policy if exists "admin write scores" on public.game_scores;
create policy "admin write scores" on public.game_scores
for all using (public.is_admin()) with check (public.is_admin());

drop policy if exists "admin write answers" on public.answers;
create policy "admin write answers" on public.answers
for all using (public.is_admin()) with check (public.is_admin());

drop policy if exists "admin write token uses" on public.game_token_uses;
create policy "admin write token uses" on public.game_token_uses
for all using (public.is_admin()) with check (public.is_admin());

drop policy if exists "admin write app_state" on public.app_state;
create policy "admin write app_state" on public.app_state
for all using (public.is_admin()) with check (public.is_admin());

-- IMPORTANT:
-- Teams (anon users) do NOT get direct insert/update on answers/token uses.
-- They call RPC `rpc_team_use_token` which runs as SECURITY DEFINER and validates.
-- So: no extra anon write policies needed.

-- =========================
-- RPC FUNCTIONS
-- =========================

-- Create a new game, init scores for both teams, return game id
create or replace function public.rpc_create_game()
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  gid uuid;
begin
  if not public.is_admin() then
    raise exception 'not authorized';
  end if;

  insert into public.games default values returning id into gid;

  insert into public.game_scores (game_id, team_id, score)
  select gid, t.id, 0 from public.teams t
  on conflict (game_id, team_id) do nothing;

  return gid;
end;
$$;

-- Set active game in app_state
create or replace function public.rpc_set_active_game(p_game_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_admin() then
    raise exception 'not authorized';
  end if;

  update public.app_state
     set active_game_id = p_game_id,
         updated_at = now()
   where id = 1;
end;
$$;

-- Admin: set current question explicitly
create or replace function public.rpc_admin_set_current_question(p_game_id uuid, p_question_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_admin() then
    raise exception 'not authorized';
  end if;

  update public.games
     set current_question_id = p_question_id
   where id = p_game_id;
end;
$$;

-- Admin: adjust score delta (+/-)
create or replace function public.rpc_admin_adjust_score(p_game_id uuid, p_team_id int, p_delta int)
returns int
language plpgsql
security definer
set search_path = public
as $$
declare
  new_score int;
begin
  if not public.is_admin() then
    raise exception 'not authorized';
  end if;

  insert into public.game_scores(game_id, team_id, score)
  values (p_game_id, p_team_id, greatest(0, p_delta))
  on conflict (game_id, team_id)
  do update set score = greatest(0, public.game_scores.score + p_delta)
  returning score into new_score;

  return new_score;
end;
$$;

-- Admin: reset token usage for a game (so you can re-use the same QR in the same game if needed)
create or replace function public.rpc_admin_reset_token(p_game_id uuid, p_token text)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if not public.is_admin() then
    raise exception 'not authorized';
  end if;

  delete from public.game_token_uses where game_id = p_game_id and token = p_token;
end;
$$;

-- Team: use token (validate not used in this game), set current question, insert answer
create or replace function public.rpc_team_use_token(
  p_game_id uuid,
  p_team_id int,
  p_token text,
  p_answer_text text default null
)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
  qid uuid;
  cat_id int;
  already_used boolean;
begin
  -- validate team
  if not exists(select 1 from public.teams t where t.id = p_team_id) then
    raise exception 'invalid team';
  end if;

  -- validate game
  if not exists(select 1 from public.games g where g.id = p_game_id) then
    raise exception 'invalid game';
  end if;

  -- validate token exists
  select qt.question_id, qt.category_id into qid, cat_id
  from public.qr_tokens qt
  where qt.token = p_token;

  if qid is null then
    raise exception 'unknown token';
  end if;

  -- check used in this game
  select exists(
    select 1 from public.game_token_uses u
    where u.game_id = p_game_id and u.token = p_token
  ) into already_used;

  if already_used then
    return json_build_object(
      'ok', false,
      'reason', 'token_already_used',
      'question_id', qid
    );
  end if;

  -- mark as used (per game)
  insert into public.game_token_uses(game_id, token, used_by_team_id)
  values (p_game_id, p_token, p_team_id);

  -- set current question
  update public.games set current_question_id = qid where id = p_game_id;

  -- insert an answer row (even if empty, for monitoring)
  insert into public.answers(game_id, question_id, team_id, answer_text)
  values (p_game_id, qid, p_team_id, p_answer_text);

  return json_build_object(
    'ok', true,
    'question_id', qid,
    'category_id', cat_id
  );
end;
$$;

-- Lock down function execution: allow anon to call only rpc_team_use_token; others require auth/admin anyway
revoke all on function public.rpc_create_game() from public;
revoke all on function public.rpc_set_active_game(uuid) from public;
revoke all on function public.rpc_admin_set_current_question(uuid, uuid) from public;
revoke all on function public.rpc_admin_adjust_score(uuid, int, int) from public;
revoke all on function public.rpc_admin_reset_token(uuid, text) from public;
revoke all on function public.rpc_team_use_token(uuid, int, text, text) from public;

grant execute on function public.rpc_team_use_token(uuid, int, text, text) to anon;
grant execute on function public.rpc_team_use_token(uuid, int, text, text) to authenticated;

grant execute on function public.rpc_create_game() to authenticated;
grant execute on function public.rpc_set_active_game(uuid) to authenticated;
grant execute on function public.rpc_admin_set_current_question(uuid, uuid) to authenticated;
grant execute on function public.rpc_admin_adjust_score(uuid, int, int) to authenticated;
grant execute on function public.rpc_admin_reset_token(uuid, text) to authenticated;

-- =========================
-- SEED DATA
-- =========================

insert into public.teams (id, name) values
  (1, 'Team 1'),
  (2, 'Team 2')
on conflict (id) do update set name = excluded.name;

insert into public.categories (id, name, icon) values
  (1, 'Artiest / feitje', 'üé§'),
  (2, 'Foto herkenning', 'üì∏'),
  (3, 'Tekst aanvullen', 'üìù'),
  (4, 'Karaoke', 'üé∂')
on conflict (id) do update set name = excluded.name, icon = excluded.icon;

-- Sample questions (vervang/uitbreid later via admin of SQL)
with q as (
  insert into public.questions (category_id, question_text, media_url, answer, duration_sec)
  values
    (1, 'In welk jaar kwam dit nummer uit?', 'spotify:track:EXAMPLE', '2012', 20),
    (2, 'Welke artiest zie je? (foto wordt steeds duidelijker)', 'https://example.com/artist.jpg', 'Artiestnaam', 20),
    (3, 'Vul de ontbrekende songtekst aan', null, '...juiste regel...', 20),
    (4, 'Karaoke: zing zoveel mogelijk woorden goed', null, null, 30)
  returning id, category_id
)
insert into public.qr_tokens (token, question_id, category_id)
select
  substr(encode(gen_random_bytes(6), 'hex'), 1, 10) as token,
  q.id,
  q.category_id
from q;
